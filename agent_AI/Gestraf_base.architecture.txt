# ‚úÖ Gestraf_base.architecture.txt (Keycloak OIDC)
# Purpose: Define the backend architecture structure used in the 'controlmat' project based on the Gestraf solution.
# Use this file to guide the GPT agent in generating consistent, modular backend logic aligned with this architecture.
# Authentication: Keycloak OIDC (no local login endpoints)

üìÅ Project Root: controlmat/
‚îî‚îÄ‚îÄ src/
    ‚îú‚îÄ‚îÄ controlmat.Api/              # API layer: Controllers, Program.cs, DI, Swagger
    ‚îú‚îÄ‚îÄ controlmat.Application/      # CQRS layer: Commands, Queries, DTOs, Validators, MediatR handlers
    ‚îú‚îÄ‚îÄ controlmat.Domain/           # Pure domain layer: Entities, Enums, Interfaces (no EF Core)
    ‚îî‚îÄ‚îÄ controlmat.Infrastructure/   # Persistence layer: DbContext, EF Core, Repositories, integrations

----------------------------------------
üß± API Layer (controlmat.Api)
----------------------------------------
- Controllers go here, thin and focused on routing and delegation.
- Inject IMediator for command handling.
- Directly inject queries for reads (e.g., IUserQueries).
- All controllers use [Authorize(Roles = "WarehouseUser")] for Keycloak role-based access.
- NO login endpoints - authentication is handled by Keycloak OIDC redirect.
- Swagger configured with JWT Bearer security for testing.
- All DI setup is centralized in DependencyInjection.cs
- Program.cs should call:
    builder.Services.AddApplicationServices();
    builder.Services.AddInfrastructureServices(builder.Configuration);
    builder.Services.AddWebServices();

----------------------------------------
üß† Application Layer (controlmat.Application)
----------------------------------------
- Organized by CQRS pattern:
  ‚Ä¢ Commands: controlmat.Application.Common.Commands.{Feature}
  ‚Ä¢ Queries:  controlmat.Application.Common.Queries.{Feature}
  ‚Ä¢ DTOs:     controlmat.Application.Common.Dto
  ‚Ä¢ Validators: FluentValidation validators per DTO (NO credential validation)
- Use MediatR for command/query dispatching.
- Commands/Queries may be structured as nested static classes with Request/Handler.
- Business logic must be isolated in Handlers, not in controllers.
- Handlers can access JWT claims via IHttpContextAccessor for user context.
- User identity comes from HttpContext.User.FindFirst("preferred_username") etc.

----------------------------------------
üèõÔ∏è Domain Layer (controlmat.Domain)
----------------------------------------
- Holds domain models, value objects, enums, and interfaces.
- No service or EF Core logic.
- No authentication/authorization logic - pure business domain.
- Example: User.cs, Material.cs, IAssignmentRepository.cs

----------------------------------------
üóÑÔ∏è Infrastructure Layer (controlmat.Infrastructure)
----------------------------------------
- EF Core DbContext: ControlmatDbContext.cs
- Repository implementations for domain interfaces
- Persistence logic and external services
- NO authentication services - auth is external via Keycloak
- Register all services via AddInfrastructureServices()

----------------------------------------
üîß Technologies Used
----------------------------------------
- EF Core for persistence
- MediatR for CQRS
- FluentValidation for input validation (NO password validation)
- AutoMapper for DTO <-> Entity mapping (optional)
- NSwag via AddOpenApiDocument for Swagger
- Serilog-based logging via ConfigureLogger() in host builder
- Microsoft.AspNetCore.Authentication.JwtBearer for Keycloak token validation
- Microsoft.AspNetCore.Authorization for role-based access control

----------------------------------------
üîê Authentication & Authorization (Keycloak OIDC)
----------------------------------------
- Authentication: JWT Bearer tokens from Keycloak realm
- Authorization: Role-based using [Authorize(Roles = "WarehouseUser")]
- No local credential storage or validation
- No password hashing or JWT issuing in this API
- User context available in handlers via HttpContext.User claims
- Claims mapping:
  ‚Ä¢ preferred_username ‚Üí User identity
  ‚Ä¢ realm_access.roles ‚Üí ASP.NET Core roles
  ‚Ä¢ sub ‚Üí Keycloak user ID (optional)

----------------------------------------
üìå Example Command Structure (with User Context)
----------------------------------------
public static class CreateUserCommand
{
    public class Request : IRequest<UserDto> { ... }
    
    public class Handler : IRequestHandler<Request, UserDto> 
    { 
        private readonly IHttpContextAccessor _httpContext;
        
        public Handler(IHttpContextAccessor httpContext) => _httpContext = httpContext;
        
        public async Task<UserDto> Handle(Request request, CancellationToken ct)
        {
            var currentUser = _httpContext.HttpContext?.User?.FindFirst("preferred_username")?.Value;
            // Business logic here...
        }
    }
}

----------------------------------------
üìå Example Query Structure
----------------------------------------
public static class GetUsersQuery
{
    public class Request : IRequest<IEnumerable<UserDto>> { ... }
    public class Handler : IRequestHandler<Request, IEnumerable<UserDto>> { ... }
}

----------------------------------------
üìå Controller Structure (Keycloak Protected)
----------------------------------------
[ApiController]
[Route("api/[controller]")]
[Authorize(Roles = "WarehouseUser")] // Keycloak role requirement
public class ExampleController : ControllerBase
{
    private readonly IMediator _mediator;
    
    public ExampleController(IMediator mediator) => _mediator = mediator;
    
    [HttpPost]
    public async Task<IActionResult> Create([FromBody] ExampleDto dto)
        => Ok(await _mediator.Send(new CreateExampleCommand.Request { Dto = dto }));
}

----------------------------------------
‚úÖ Agent Instructions
----------------------------------------
When generating backend features for controlmat:
- Respect Gestraf's layered project layout and CQRS patterns
- Use thin controllers with MediatR/Query injection
- All controllers protected with [Authorize(Roles = "WarehouseUser")]
- NO authentication endpoints - delegate to Keycloak
- Organize files per feature into Commands, Queries, DTOs, Validators
- Use DependencyInjection.cs for all service registrations
- Keep Domain and Infrastructure clearly separated
- Access user context via IHttpContextAccessor in handlers when needed
- Configure JWT Bearer authentication pointing to Keycloak Authority
- Ensure CORS is configured for frontend integration