# ‚úÖ Gestraf-Aligned Error Codes ‚Äì SUMISAN Wash Management (Keycloak Auth)

This document maps each API endpoint and error code to its corresponding **CQRS command or query handler**.

All business rule validations and exceptions are handled within **Handlers** (not controllers), and return consistent HTTP codes using middleware or controller-level result mapping.

**Authentication is handled by Keycloak OIDC - no local credential validation.**

---

## üîê Authentication & Authorization Errors

### Global Auth/Authz Errors (Middleware Level)
* `401 Unauthorized` ‚Üí Missing, expired, or invalid JWT token from Keycloak
* `403 Forbidden` ‚Üí Valid token but insufficient role (not `WarehouseUser`)
* `500 Internal Server Error` ‚Üí Unexpected exception (handled via middleware + Serilog)

**Note**: There are **no local login endpoints** in this API. All authentication is delegated to Keycloak.

---

## üöø Start Wash

### `POST /api/washing`

* **Handler:** `StartWashCommand`
* **Auth:** Requires `WarehouseUser` role
* **Errors:**
  * `400 Bad Request` ‚Üí Missing `MachineId`, `StartUserId`, or empty `ProtEntries[]` (FluentValidation)
  * `401 Unauthorized` ‚Üí Missing/invalid Keycloak JWT
  * `403 Forbidden` ‚Üí Valid JWT but missing `WarehouseUser` role
  * `409 Conflict` ‚Üí
    * Max 2 active washes (enforced via `IWashingRepository.CountActiveAsync()`)
    * Selected machine already in use (via `IWashingRepository.IsMachineInUseAsync()`)

---

## üß∫ Finish Wash

### `PUT /api/washing/{id}/finish`

* **Handler:** `FinishWashCommand`
* **Auth:** Requires `WarehouseUser` role
* **Errors:**
  * `400 Bad Request` ‚Üí DTO validation failure (missing `EndUserId`)
  * `401 Unauthorized` ‚Üí Missing/invalid Keycloak JWT
  * `403 Forbidden` ‚Üí 
    * Valid JWT but missing `WarehouseUser` role, OR
    * No photos uploaded for this wash (checked via `IPhotoRepository.GetByWashId()`)
  * `404 Not Found` ‚Üí Wash does not exist (null from `IWashingRepository.GetByIdAsync()`)
  * `409 Conflict` ‚Üí Wash is already finished (Status = 'F')

---

## üì¶ Add Prot

### `POST /api/washing/{id}/prots`

* **Handler:** `AddProtCommand`
* **Auth:** Requires `WarehouseUser` role
* **Errors:**
  * `400 Bad Request` ‚Üí Invalid prot format (validator-level: regex patterns for ProtId, BatchNumber, BagNumber)
  * `401 Unauthorized` ‚Üí Missing/invalid Keycloak JWT
  * `403 Forbidden` ‚Üí Valid JWT but missing `WarehouseUser` role
  * `404 Not Found` ‚Üí Wash not found (repository returns null)
  * `409 Conflict` ‚Üí Wash is already finished (Status = 'F')

---

## üñº Upload Photo

### `POST /api/washing/{id}/photos`

* **Handler:** `UploadPhotoCommand`
* **Auth:** Requires `WarehouseUser` role
* **Errors:**
  * `400 Bad Request` ‚Üí No file provided or unsupported format (handler or `PhotoUploadValidator`)
  * `401 Unauthorized` ‚Üí Missing/invalid Keycloak JWT
  * `403 Forbidden` ‚Üí Valid JWT but missing `WarehouseUser` role
  * `404 Not Found` ‚Üí Wash not found
  * `409 Conflict` ‚Üí Already reached 99 photos (business rule)
  * `413 Payload Too Large` ‚Üí File exceeds size limit (enforced via request limit config)

---

## üîç Get Active Washes

### `GET /api/washing/active`

* **Handler:** `GetActiveWashesQuery`
* **Auth:** May be `[AllowAnonymous]` or require `WarehouseUser` role
* **Errors:**
  * `200 OK` ‚Üí Always returns 0‚Äì2 items (no business failure cases)
  * `401 Unauthorized` ‚Üí Missing/invalid JWT (if auth required)
  * `403 Forbidden` ‚Üí Missing role (if auth required)

---

## üîç Get Wash By ID

### `GET /api/washing/{id}`

* **Handler:** `GetWashByIdQuery`
* **Auth:** Requires `WarehouseUser` role
* **Errors:**
  * `200 OK` ‚Üí Wash found and returned with nested Prots/Photos
  * `401 Unauthorized` ‚Üí Missing/invalid Keycloak JWT
  * `403 Forbidden` ‚Üí Valid JWT but missing `WarehouseUser` role
  * `404 Not Found` ‚Üí ID does not match any existing wash

---

## ‚úÖ Handler-Based Error Principles (Gestraf + Keycloak)

### Separation of Concerns:
* **Authentication**: Handled by ASP.NET Core JWT Bearer middleware + Keycloak token validation
* **Authorization**: Handled by `[Authorize(Roles = "WarehouseUser")]` attributes on controllers
* **Input Validation**: Enforced via FluentValidation in `Application.Common.Validators`
* **Business Rules**: Checked inside Command/Query handlers (e.g., max washes, photo count)
* **Error Mapping**: NotFound/Conflict/Forbidden errors thrown by handlers, mapped via exception middleware

### Key Changes from Local Auth:
* **No credential validation** in handlers - all auth is external via Keycloak
* **No password checks** anywhere in the application code
* **No local JWT issuing** - tokens come from Keycloak realm
* **User claims** extracted from `HttpContext.User` in handlers as needed
* **Role mapping** from Keycloak `realm_access.roles` to ASP.NET Core roles

This keeps all error behavior declarative, testable, and in line with Gestraf's CQRS and MediatR-based design while delegating all authentication concerns to Keycloak.