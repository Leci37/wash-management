# ✅ Wash Management Agent Spec – Gestraf Aligned (CQRS + Keycloak Auth)

This document rewrites the SUMISAN Wash Management agent spec to align with the **Gestraf architecture**, replacing layered service/repository logic with **CQRS-based Command/Query handlers** and **Keycloak OIDC authentication**.

---

## 🧱 Project Structure

```
controlmat/
└── src/
    ├── controlmat.Api/              // API layer: controllers only
    ├── controlmat.Application/      // CQRS: commands, queries, DTOs, validators
    ├── controlmat.Domain/           // Domain entities, enums, interfaces (no EF logic)
    └── controlmat.Infrastructure/   // EF Core, repositories, integrations
```

---

## 📌 Domain Models (controlmat.Domain.Entities)

* `User`: UserId, UserName, Role (local user records for business operations)
* `Machine`: Id, Name
* `Washing`: WashingId (YYMMDDXX), MachineId, Start/End Timestamps, UserIds, Status ('P' or 'F'), Observations
* `Prot`: WashingId FK, ProtId, BatchNumber, BagNumber
* `Photo`: WashingId FK, FilePath, FileName, CreatedAt
* `Parameter`: Config settings (e.g., ImagePath)

---

## ✅ CQRS Command / Query Use Cases

### 🧼 StartWashCommand

* **DTO**: `NewWashDto`
* **Handler Responsibilities**:
  * Validate: Max 2 active washes, machine availability
  * Ensure: ≥1 prot provided
  * Generate WashingId in `YYMMDDXX` format
  * Create `Washing` + `Prot[]`
  * Save via `IWashingRepository`
  * Return: `WashingResponseDto`

### ✅ AddProtCommand

* **DTO**: `AddProtDto`
* **Handler Responsibilities**:
  * Validate: Wash is in 'P' state
  * Create new `Prot` linked to wash
  * Persist via `IProtRepository`

### 📷 UploadPhotoCommand

* **DTO**: Multipart `PhotoUploadDto`
* **Handler Responsibilities**:
  * Validate: wash exists & is in-progress
  * Check: photo count < 99
  * Build file path: `{ImagePath}/{Year}/{WashingId}_{XX}.jpg`
  * Save file, create `Photo`, store via `IPhotoRepository`

### 🧺 FinishWashCommand

* **DTO**: `FinishWashDto`
* **Handler Responsibilities**:
  * Validate: Wash is 'P'
  * Check: ≥1 prot and ≥1 photo exists
  * Update: Set `Status = 'F'`, timestamps, end user, observations
  * Save via `IWashingRepository`

### 🔍 GetActiveWashesQuery

* **Returns**: List of `WashingResponseDto`
* **Handler Responsibilities**:
  * Query all washes where `Status = 'P'`
  * Map entities to DTOs (with nested Prots)

### 🔍 GetWashByIdQuery

* **Returns**: Single `WashingResponseDto`
* **Handler Responsibilities**:
  * Load wash + related Prots + Photos
  * Return full wash detail

---

## 🧾 CQRS Component Placement

| Feature           | Component Type | Location                                                   |
| ----------------- | -------------- | ---------------------------------------------------------- |
| Start Wash        | Command        | `Application.Common.Commands.Washing.StartWashCommand`     |
| Add Prot          | Command        | `Application.Common.Commands.Washing.AddProtCommand`       |
| Upload Photo      | Command        | `Application.Common.Commands.Washing.UploadPhotoCommand`   |
| Finish Wash       | Command        | `Application.Common.Commands.Washing.FinishWashCommand`    |
| Get Active Washes | Query          | `Application.Common.Queries.Washing.GetActiveWashesQuery`  |
| Get by ID         | Query          | `Application.Common.Queries.Washing.GetWashByIdQuery`      |

---

## 🧠 Validation Strategy

* Validators live under `Application.Common.Validators`
* Examples:
  * `NewWashValidator`
  * `AddProtValidator`
  * `FinishWashValidator`
* Enforced automatically via FluentValidation + `services.AddValidatorsFromAssemblyContaining<T>()`

---

## 🧾 Entity Relationship Summary

```
Washing
 ├── 1:M → Prot
 ├── 1:M → Photo
 ├── M:1 → User (StartUserId / EndUserId)
 └── M:1 → Machine
```

---

## 🔒 Authorization Strategy (Keycloak OIDC)

### Authentication Flow:
1. Frontend redirects user to Keycloak login
2. Keycloak returns JWT token to frontend
3. Frontend includes token in `Authorization: Bearer <token>` header
4. Backend validates token against Keycloak realm

### Authorization Implementation:
* All endpoints use `[Authorize(Roles = "WarehouseUser")]`
* User identity extracted from JWT claims in handlers:
  * `HttpContext.User.FindFirst("preferred_username")?.Value` → Username
  * `HttpContext.User.FindFirst("sub")?.Value` → Keycloak User ID
  * `HttpContext.User.IsInRole("WarehouseUser")` → Role check
* Local `Users` table maintains business-specific user data (UserId, UserName)
* Handlers map between Keycloak claims and local User entities as needed

### Key Points:
* **No password validation** in this API
* **No local login endpoints** - all auth via Keycloak
* **No credential storage** - tokens validated against Keycloak
* JWT contains roles from `realm_access.roles` mapped to ASP.NET roles

---

## ✅ Summary

| Area                  | Old Architecture         | Gestraf + Keycloak Alignment              |
| --------------------- | ------------------------ | ----------------------------------------- |
| Controllers           | Services called directly | Use `IMediator.Send(...)` for all logic  |
| Business Logic        | WashService              | CQRS Handlers only                        |
| Authentication        | Local login/password     | Keycloak OIDC redirect                    |
| Authorization         | Custom JWT issuing       | Keycloak JWT validation                   |
| User Claims           | Database lookup          | JWT claims + optional DB correlation     |
| Validation            | Manual or inline         | FluentValidation in Validators            |
| Logging               | Optional or mixed        | Per-handler via `ILogger<T>`              |
| Errors & Status Codes | Controller-driven        | Thrown/mapped in Handler                  |

This document defines a robust and testable CQRS-based backend with Keycloak authentication, eliminating service bloat and local credential management while enforcing proper separation per Gestraf principles.