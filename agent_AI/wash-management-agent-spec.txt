# âœ… Wash Management Agent Spec â€“ Gestraf Aligned (CQRS)

This document rewrites the SUMISAN Wash Management agent spec to align with the **Gestraf architecture**, replacing layered service/repository logic with **CQRS-based Command/Query handlers**.

---

## ðŸ§± Project Structure

```
controlmat/
â””â”€â”€ src/
    â”œâ”€â”€ controlmat.Api/              // API layer: controllers only
    â”œâ”€â”€ controlmat.Application/      // CQRS: commands, queries, DTOs, validators
    â”œâ”€â”€ controlmat.Domain/           // Domain entities, enums, interfaces (no EF logic)
    â””â”€â”€ controlmat.Infrastructure/   // EF Core, repositories, integrations
```

---

## ðŸ“Œ Domain Models (controlmat.Domain.Entities)

* `User`: UserId, UserName, PasswordHash, Role
* `Machine`: Id, Name
* `Washing`: WashingId (YYMMDDXX), MachineId, Start/End Timestamps, UserIds, Status ('P' or 'F'), Observations
* `Prot`: WashingId FK, ProtId, BatchNumber, BagNumber
* `Photo`: WashingId FK, FilePath, FileName, CreatedAt
* `Parameter`: Config settings (e.g., ImagePath)

---

## âœ… CQRS Command / Query Use Cases

### ðŸ§¼ StartWashCommand

* **DTO**: `NewWashDto`
* **Handler Responsibilities**:

  * Validate: Max 2 active washes, machine availability
  * Ensure: â‰¥1 prot provided
  * Generate WashingId in `YYMMDDXX` format
  * Create `Washing` + `Prot[]`
  * Save via `IWashingRepository`
  * Return: `WashingResponseDto`

### âœ… AddProtCommand

* **DTO**: `AddProtDto`
* **Handler Responsibilities**:

  * Validate: Wash is in 'P' state
  * Create new `Prot` linked to wash
  * Persist via `IProtRepository`

### ðŸ“· UploadPhotoCommand

* **DTO**: Multipart `PhotoUploadDto`
* **Handler Responsibilities**:

  * Validate: wash exists & is in-progress
  * Check: photo count < 99
  * Build file path: `{ImagePath}/{Year}/{WashingId}_{XX}.jpg`
  * Save file, create `Photo`, store via `IPhotoRepository`

### ðŸ§º FinishWashCommand

* **DTO**: `FinishWashDto`
* **Handler Responsibilities**:

  * Validate: Wash is 'P'
  * Check: â‰¥1 prot and â‰¥1 photo exists
  * Update: Set `Status = 'F'`, timestamps, end user, observations
  * Save via `IWashingRepository`

### ðŸ” GetActiveWashesQuery

* **Returns**: List of `WashingResponseDto`
* **Handler Responsibilities**:

  * Query all washes where `Status = 'P'`
  * Map entities to DTOs (with nested Prots)

### ðŸ” GetWashByIdQuery

* **Returns**: Single `WashingResponseDto`
* **Handler Responsibilities**:

  * Load wash + related Prots + Photos
  * Return full wash detail

### ðŸ” AuthenticateUserCommand

* **DTO**: `LoginRequestDto`
* **Handler Responsibilities**:

  * Validate: username/password
  * Issue JWT if successful

---

## ðŸ§¾ CQRS Component Placement

| Feature           | Component Type | Location                                                   |
| ----------------- | -------------- | ---------------------------------------------------------- |
| Start Wash        | Command        | `Application.Common.Commands.Washing.StartWashCommand`     |
| Add Prot          | Command        | `Application.Common.Commands.Washing.AddProtCommand`       |
| Upload Photo      | Command        | `Application.Common.Commands.Washing.UploadPhotoCommand`   |
| Finish Wash       | Command        | `Application.Common.Commands.Washing.FinishWashCommand`    |
| Get Active Washes | Query          | `Application.Common.Queries.Washing.GetActiveWashesQuery`  |
| Get by ID         | Query          | `Application.Common.Queries.Washing.GetWashByIdQuery`      |
| Login             | Command        | `Application.Common.Commands.Auth.AuthenticateUserCommand` |

---

## ðŸ§  Validation Strategy

* Validators live under `Application.Common.Validators`
* Examples:

  * `NewWashValidator`
  * `AddProtValidator`
  * `FinishWashValidator`
* Enforced automatically via FluentValidation + `services.AddValidatorsFromAssemblyContaining<T>()`

---

## ðŸ§¾ Entity Relationship Summary

```
Washing
 â”œâ”€â”€ 1:M â†’ Prot
 â”œâ”€â”€ 1:M â†’ Photo
 â”œâ”€â”€ M:1 â†’ User (StartUserId / EndUserId)
 â””â”€â”€ M:1 â†’ Machine
```

---

## ðŸ”’ Authorization Strategy

* All endpoints use JWT + `[Authorize(Roles = "WarehouseUser")]`
* Tokens generated in `AuthenticateUserCommand` using role claims

---

## âœ… Summary

| Area                  | Old Architecture         | Gestraf Alignment                       |
| --------------------- | ------------------------ | --------------------------------------- |
| Controllers           | Services called directly | Use `IMediator.Send(...)` for all logic |
| Business Logic        | WashService              | CQRS Handlers only                      |
| Validation            | Manual or inline         | FluentValidation in Validators          |
| Logging               | Optional or mixed        | Per-handler via `ILogger<T>`            |
| Errors & Status Codes | Controller-driven        | Thrown/mapped in Handler                |

This document defines a robust and testable CQRS-based backend, eliminating service bloat and enforcing proper separation per Gestraf principles.
