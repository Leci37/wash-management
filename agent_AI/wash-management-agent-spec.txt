# âœ… Wash Management Agent Spec â€“ Gestraf Aligned (CQRS + Keycloak Auth)

This document rewrites the SUMISAN Wash Management agent spec to align with the **Gestraf architecture**, replacing layered service/repository logic with **CQRS-based Command/Query handlers** and **Keycloak OIDC authentication**.

---

## ðŸ§± Project Structure

```
controlmat/
â””â”€â”€ src/
    â”œâ”€â”€ controlmat.Api/              // API layer: controllers only
    â”œâ”€â”€ controlmat.Application/      // CQRS: commands, queries, DTOs, validators
    â”œâ”€â”€ controlmat.Domain/           // Domain entities, enums, interfaces (no EF logic)
    â””â”€â”€ controlmat.Infrastructure/   // EF Core, repositories, integrations
```

---

## ðŸ“Œ Domain Models (controlmat.Domain.Entities)

* `User`: UserId, UserName, Role (local user records for business operations)
* `Machine`: Id, Name
* `Washing`: WashingId (YYMMDDXX), MachineId, Start/End Timestamps, UserIds, Status ('P' or 'F'), Observations
* `Prot`: WashingId FK, ProtId, BatchNumber, BagNumber
* `Photo`: WashingId FK, FilePath, FileName, CreatedAt
* `Parameter`: Config settings (e.g., ImagePath)

---

## âœ… CQRS Command / Query Use Cases

### ðŸ§¼ StartWashCommand

* **DTO**: `NewWashDto`
* **Handler Responsibilities**:
  * Validate: Max 2 active washes, machine availability
  * Ensure: â‰¥1 prot provided
  * Generate WashingId in `YYMMDDXX` format
  * Create `Washing` + `Prot[]`
  * Save via `IWashingRepository`
  * Return: `WashingResponseDto`

### âœ… AddProtCommand

* **DTO**: `AddProtDto`
* **Handler Responsibilities**:
  * Validate: Wash is in 'P' state
  * Create new `Prot` linked to wash
  * Persist via `IProtRepository`

### ðŸ“· UploadPhotoCommand

* **DTO**: Multipart `PhotoUploadDto`
* **Handler Responsibilities**:
  * Validate: wash exists & is in-progress
  * Check: photo count < 99
  * Build file path: `{ImagePath}/{Year}/{WashingId}_{XX}.jpg`
  * Save file, create `Photo`, store via `IPhotoRepository`

### ðŸ§º FinishWashCommand

* **DTO**: `FinishWashDto`
* **Handler Responsibilities**:
  * Validate: Wash is 'P'
  * Check: â‰¥1 prot and â‰¥1 photo exists
  * Update: Set `Status = 'F'`, timestamps, end user, observations
  * Save via `IWashingRepository`

### ðŸ” GetActiveWashesQuery

* **Returns**: List of `WashingResponseDto`
* **Handler Responsibilities**:
  * Query all washes where `Status = 'P'`
  * Map entities to DTOs (with nested Prots)

### ðŸ” GetWashByIdQuery

* **Returns**: Single `WashingResponseDto`
* **Handler Responsibilities**:
  * Load wash + related Prots + Photos
  * Return full wash detail

---

## ðŸ§¾ CQRS Component Placement

| Feature           | Component Type | Location                                                   |
| ----------------- | -------------- | ---------------------------------------------------------- |
| Start Wash        | Command        | `Application.Common.Commands.Washing.StartWashCommand`     |
| Add Prot          | Command        | `Application.Common.Commands.Washing.AddProtCommand`       |
| Upload Photo      | Command        | `Application.Common.Commands.Washing.UploadPhotoCommand`   |
| Finish Wash       | Command        | `Application.Common.Commands.Washing.FinishWashCommand`    |
| Get Active Washes | Query          | `Application.Common.Queries.Washing.GetActiveWashesQuery`  |
| Get by ID         | Query          | `Application.Common.Queries.Washing.GetWashByIdQuery`      |

---

## ðŸ§  Validation Strategy

* Validators live under `Application.Common.Validators`
* Examples:
  * `NewWashValidator`
  * `AddProtValidator`
  * `FinishWashValidator`
* Enforced automatically via FluentValidation + `services.AddValidatorsFromAssemblyContaining<T>()`

---

## ðŸ§¾ Entity Relationship Summary

```
Washing
 â”œâ”€â”€ 1:M â†’ Prot
 â”œâ”€â”€ 1:M â†’ Photo
 â”œâ”€â”€ M:1 â†’ User (StartUserId / EndUserId)
 â””â”€â”€ M:1 â†’ Machine
```

---

## ðŸ”’ Authorization Strategy (Keycloak OIDC)

### Authentication Flow:
1. Frontend redirects user to Keycloak login
2. Keycloak returns JWT token to frontend
3. Frontend includes token in `Authorization: Bearer <token>` header
4. Backend validates token against Keycloak realm

### Authorization Implementation:
* All endpoints use `[Authorize(Roles = "WarehouseUser")]`
* User identity extracted from JWT claims in handlers:
  * `HttpContext.User.FindFirst("preferred_username")?.Value` â†’ Username
  * `HttpContext.User.FindFirst("sub")?.Value` â†’ Keycloak User ID
  * `HttpContext.User.IsInRole("WarehouseUser")` â†’ Role check
* Local `Users` table maintains business-specific user data (UserId, UserName)
* Handlers map between Keycloak claims and local User entities as needed

### Key Points:
* **No password validation** in this API
* **No local login endpoints** - all auth via Keycloak
* **No credential storage** - tokens validated against Keycloak
* JWT contains roles from `realm_access.roles` mapped to ASP.NET roles

---

## âœ… Summary

| Area                  | Old Architecture         | Gestraf + Keycloak Alignment              |
| --------------------- | ------------------------ | ----------------------------------------- |
| Controllers           | Services called directly | Use `IMediator.Send(...)` for all logic  |
| Business Logic        | WashService              | CQRS Handlers only                        |
| Authentication        | Local login/password     | Keycloak OIDC redirect                    |
| Authorization         | Custom JWT issuing       | Keycloak JWT validation                   |
| User Claims           | Database lookup          | JWT claims + optional DB correlation     |
| Validation            | Manual or inline         | FluentValidation in Validators            |
| Logging               | Optional or mixed        | Per-handler via `ILogger<T>`              |
| Errors & Status Codes | Controller-driven        | Thrown/mapped in Handler                  |

This document defines a robust and testable CQRS-based backend with Keycloak authentication, eliminating service bloat and local credential management while enforcing proper separation per Gestraf principles.