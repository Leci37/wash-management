// üìÅ controlmat.Api
// üîß Gestraf-Aligned Deployment Configuration for SUMISAN (Keycloak OIDC)
// This version configures JWT Bearer authentication against a Keycloak realm
// and aligns with Gestraf's separation of concerns for service registration and startup logic.

using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.EntityFrameworkCore;
using Microsoft.IdentityModel.Tokens;
using Serilog;
using System.Text;
using controlmat.Application;
using controlmat.Infrastructure;

var builder = WebApplication.CreateBuilder(args);

// ‚úÖ Serilog Logging Setup
Log.Logger = new LoggerConfiguration()
    .Enrich.FromLogContext()
    .Enrich.WithThreadId()
    .Enrich.WithEnvironmentUserName()
    .WriteTo.Console()
    .WriteTo.File("Logs/sumisan-log-.log", rollingInterval: RollingInterval.Day)
    .CreateLogger();

builder.Host.UseSerilog();

// ‚úÖ Add Configuration-Based Services
var config = builder.Configuration;

// ‚úÖ EF Core DbContext (via Infrastructure)
builder.Services.AddInfrastructureServices(config);

// ‚úÖ Register Application Layer (MediatR, AutoMapper, Validators)
builder.Services.AddApplicationServices();

// ‚úÖ Authentication / JWT Bearer (Keycloak OIDC)
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        // Keycloak realm configuration
        options.Authority = config["Keycloak:Authority"]; // e.g., https://keycloak.example.com/realms/sumisan
        options.Audience = config["Keycloak:Audience"];   // e.g., sumisan-api
        options.RequireHttpsMetadata = !builder.Environment.IsDevelopment();
        
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuer = true,
            ValidateAudience = true,
            ValidateLifetime = true,
            ValidateIssuerSigningKey = true,
            ClockSkew = TimeSpan.FromMinutes(5), // Allow 5min clock skew
            RoleClaimType = "roles", // Map to realm_access.roles from Keycloak
            NameClaimType = "preferred_username" // Use preferred_username as name claim
        };

        // Optional: Custom events for debugging
        options.Events = new JwtBearerEvents
        {
            OnAuthenticationFailed = context =>
            {
                Log.Warning("JWT Authentication failed: {Error}", context.Exception?.Message);
                return Task.CompletedTask;
            },
            OnTokenValidated = context =>
            {
                Log.Debug("JWT token validated for user: {User}", 
                    context.Principal?.FindFirst("preferred_username")?.Value ?? "Unknown");
                return Task.CompletedTask;
            }
        };
    });

// ‚úÖ Authorization with role-based policies
builder.Services.AddAuthorization(options =>
{
    // Default policy requires WarehouseUser role
    options.AddPolicy("WarehouseUser", policy =>
        policy.RequireRole("WarehouseUser"));
        
    // Optional: More granular policies
    options.AddPolicy("WashOperator", policy =>
        policy.RequireRole("WarehouseUser", "WashOperator"));
});

// ‚úÖ CORS for Keycloak integration (adjust origins as needed)
builder.Services.AddCors(options =>
{
    options.AddPolicy("AllowKeycloakOrigins", policy =>
    {
        policy.WithOrigins(
            config["Keycloak:AllowedOrigins"]?.Split(',') ?? new[] { "http://localhost:4200" }
        )
        .AllowAnyHeader()
        .AllowAnyMethod()
        .AllowCredentials();
    });
});

// ‚úÖ Swagger with JWT Bearer support
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen(c =>
{
    c.AddSecurityDefinition("Bearer", new Microsoft.OpenApi.Models.OpenApiSecurityScheme
    {
        Description = "JWT Authorization header using the Bearer scheme. Enter 'Bearer' [space] and then your token.",
        Name = "Authorization",
        In = Microsoft.OpenApi.Models.ParameterLocation.Header,
        Type = Microsoft.OpenApi.Models.SecuritySchemeType.ApiKey,
        Scheme = "Bearer"
    });

    c.AddSecurityRequirement(new Microsoft.OpenApi.Models.OpenApiSecurityRequirement
    {
        {
            new Microsoft.OpenApi.Models.OpenApiSecurityScheme
            {
                Reference = new Microsoft.OpenApi.Models.OpenApiReference
                {
                    Type = Microsoft.OpenApi.Models.ReferenceType.SecurityScheme,
                    Id = "Bearer"
                }
            },
            Array.Empty<string>()
        }
    });
});

// ‚úÖ Add MVC Controllers
builder.Services.AddControllers();

var app = builder.Build();

// ‚úÖ Swagger UI in Development
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI(c =>
    {
        c.SwaggerEndpoint("/swagger/v1/swagger.json", "SUMISAN API V1");
        c.DisplayRequestDuration();
    });
}

// ‚úÖ Middleware pipeline
app.UseHttpsRedirection();
app.UseCors("AllowKeycloakOrigins");
app.UseAuthentication(); // Must come before UseAuthorization
app.UseAuthorization();
app.MapControllers();

// ‚úÖ Health check endpoint (optional)
app.MapGet("/health", () => new { Status = "Healthy", Timestamp = DateTime.UtcNow })
   .AllowAnonymous();

app.Run();

/*
üìã Required appsettings.json configuration:

{
  "Keycloak": {
    "Authority": "https://your-keycloak-server/realms/sumisan",
    "Audience": "sumisan-api",
    "AllowedOrigins": "http://localhost:4200,https://sumisan-frontend.example.com"
  },
  "ConnectionStrings": {
    "DefaultConnection": "Server=localhost,1434;Database=SUMISAN;User Id=sa;Password=Sumisan2024!;TrustServerCertificate=true;"
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning",
      "Microsoft.EntityFrameworkCore": "Information"
    }
  }
}

üîß Keycloak Configuration Notes:
1. Create realm: 'sumisan'
2. Create client: 'sumisan-api' (Bearer-only or confidential)
3. Create role: 'WarehouseUser' 
4. Assign role to users who should access the API
5. Configure valid redirect URIs for frontend
6. Enable CORS if frontend and API are on different domains

üîê JWT Claims Mapping:
- preferred_username ‚Üí User identity in handlers
- realm_access.roles ‚Üí ASP.NET Core roles
- sub ‚Üí Keycloak user ID (optional correlation)
- name ‚Üí Display name (optional)
*/