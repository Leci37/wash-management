# üß† Gestraf-Aligned API Endpoint Spec for SUMISAN (Keycloak-enabled)

This document defines the CQRS-driven API endpoints for the SUMISAN Wash Management backend,
structured according to the Gestraf architecture ‚Äî with **authentication delegated to Keycloak**.
There is **no /api/auth/login** endpoint in this API. Clients obtain tokens from Keycloak (OIDC),
then call this API with a Bearer token.

AuthN: JwtBearer (Keycloak realm)
AuthZ: [Authorize(Roles = "WarehouseUser")] unless otherwise noted
Failure semantics: 401 (no/invalid token), 403 (insufficient role)

---

## üîê Authentication & Authorization

- All protected endpoints require a **Keycloak-issued JWT** in the `Authorization: Bearer <token>` header.
- Controllers are thin; **no credential checks** or local password validation.
- Handlers use MediatR and **enforce business rules only**.
- Recommended JWT mappings:
  - Role: `realm_access.roles` ‚Üí ASP.NET roles (e.g., `WarehouseUser`)
  - Optional user claims for auditing: `sub`, `preferred_username`, `name`

---

## üß± WashingController (controlmat.Api)

```csharp
[ApiController]
[Route("api/washing")]
[Authorize(Roles = "WarehouseUser")]
public class WashingController : ControllerBase
{
    private readonly IMediator _mediator;

    public WashingController(IMediator mediator) => _mediator = mediator;

    [HttpPost]
    public async Task<IActionResult> Start([FromBody] NewWashDto dto)
        => Ok(await _mediator.Send(new StartWashCommand.Request(dto)));

    [HttpPut("{id}/finish")]
    public async Task<IActionResult> Finish(long id, [FromBody] FinishWashDto dto)
        => Ok(await _mediator.Send(new FinishWashCommand.Request(id, dto)));

    [HttpPost("{id}/photos")]
    [RequestSizeLimit(20_000_000)] // optional: 20 MB
    public async Task<IActionResult> UploadPhoto(long id, [FromForm] IFormFile file)
        => Ok(await _mediator.Send(new UploadPhotoCommand.Request(id, file)));

    [HttpPost("{id}/prots")]
    public async Task<IActionResult> AddProt(long id, [FromBody] AddProtDto dto)
        => Ok(await _mediator.Send(new AddProtCommand.Request(id, dto)));

    [HttpGet("active")]
    [AllowAnonymous] // optional if allowed to be public; otherwise remove
    public async Task<IActionResult> GetActive()
        => Ok(await _mediator.Send(new GetActiveWashesQuery.Request()));

    [HttpGet("{id}")]
    public async Task<IActionResult> GetById(long id)
        => Ok(await _mediator.Send(new GetWashByIdQuery.Request(id)));
}
```

---

## üß† Application Layer ‚Äì Commands/Queries

```csharp
public static class StartWashCommand
{
    public record Request(NewWashDto Dto) : IRequest<WashDto>;
    public class Handler : IRequestHandler<Request, WashDto> { /* validate, map, persist */ }
}

public static class FinishWashCommand
{
    public record Request(long WashId, FinishWashDto Dto) : IRequest<Unit>;
    public class Handler : IRequestHandler<Request, Unit> { /* validate photos, update */ }
}

public static class UploadPhotoCommand
{
    public record Request(long WashId, IFormFile File) : IRequest<string>;
    public class Handler : IRequestHandler<Request, string> { /* naming, storage, DB */ }
}

public static class AddProtCommand
{
    public record Request(long WashId, AddProtDto Dto) : IRequest<Unit>;
    public class Handler : IRequestHandler<Request, Unit> { /* validate + save prot */ }
}

public static class GetActiveWashesQuery
{
    public record Request : IRequest<List<WashDto>>;
    public class Handler : IRequestHandler<Request, List<WashDto>> { /* read-only */ }
}

public static class GetWashByIdQuery
{
    public record Request(long Id) : IRequest<WashDto>;
    public class Handler : IRequestHandler<Request, WashDto> { /* load washing + prots + photos */ }
}
```

---

## üóÇ DTOs (Application.Common.Dto)

* `NewWashDto`
* `FinishWashDto`
* `AddProtDto`
* `WashDto` (includes nested `ProtDto[]`, `PhotoDto[]`)

---

## üîç FluentValidation Validators (Application.Common.Validators)

* `NewWashValidator`
* `FinishWashValidator`
* `AddProtValidator`

Validators perform field validation only; no credential checks.

---

## üîÅ Response and Status Codes (by Handler)

| Endpoint                        | Handler Class          | Status Codes       |
| ------------------------------- | ---------------------- | ------------------ |
| POST `/api/washing`             | `StartWashCommand`     | 201/200, 400, 401, 403, 409 |
| PUT `/api/washing/{id}/finish`  | `FinishWashCommand`    | 200, 400, 401, 403, 409 |
| POST `/api/washing/{id}/prots`  | `AddProtCommand`       | 201/200, 400, 401, 403, 404, 409 |
| POST `/api/washing/{id}/photos` | `UploadPhotoCommand`   | 201/200, 400, 401, 403, 409, 413 |
| GET `/api/washing/active`       | `GetActiveWashesQuery` | 200, 401, 403 (if protected) |
| GET `/api/washing/{id}`         | `GetWashByIdQuery`     | 200, 401, 403, 404 |

---

## ‚úÖ CQRS Organization Summary

| Feature      | Command or Query Class | Notes                         |
| ------------ | ---------------------- | ----------------------------- |
| Start Wash   | `StartWashCommand`     | Validates max washes, machine |
| Finish Wash  | `FinishWashCommand`    | Requires photo check          |
| Add Prot     | `AddProtCommand`       | Wash must be active           |
| Upload Photo | `UploadPhotoCommand`   | Validates naming/limit        |
| Get Active   | `GetActiveWashesQuery` | Query only                    |
| Get by ID    | `GetWashByIdQuery`     | Nested DTOs returned          |

This spec ensures full CQRS separation, handler-based enforcement of business logic, and DTO-driven validation ‚Äî compliant with the **Gestraf architecture** with **Keycloak authentication**.